<html>

<head>

    <script src="d3.js" ></script>

</head>

<body>

    <h1>Busses and Lines</h1>
    <div>
        <p>Hello, world! </p>
        <svg id="map"></svg>
    </div>

</body>

<script type="module">
    import {text} from "https://cdn.skypack.dev/d3-fetch@3";
    
    // global data variable
    let data = {
        "zips" : {}, // zip code geojson
        "busStrings": [],
        "lineStrings": [],
        "busObj": {
            "type": "FeatureCollection",
            "features": []
        },  
        "lineObj": {
            "type": "FeatureCollection",
            "features": []
        },
        "projection": {},

    }

    function loadData() {
        return Promise.all([
            d3.json("data/geojsons/bay.geo.json"),
            text('data/p13uhs0_1247/DSSfiles/Buscoords.dss'),
            text('data/p13uhs0_1247/DSSfiles/Lines.dss'),
            text('data/p13uhs0_1247/DSSfiles/p13uhs0_1247--p13udt13213/Lines.dss'),
            text('data/p13uhs0_1247/DSSfiles/p13uhs0_1247--p13udt13219/Lines.dss'),
            text('data/p13uhs0_1247/DSSfiles/p13uhs0_1247--p13udt15681/Lines.dss'),
            text('data/p13uhs0_1247/DSSfiles/p13uhs0_1247--p13udt18158/Lines.dss'),
        ]).then(resps => {
            data.zips = resps[0];
            data.busStrings.push(resps[1]);
            for (let i = 2; i < 3; i += 1) { // todo import other lines files
                data.lineStrings.push(resps[i])
            }
            return data
        })
    }

    function parseData() {
         // initialize geoJSON objects for storing output of parsing functions
        data.busStrings.forEach(b => {
            data.busObj.features.push(...parseBusData(b))
        })
        data.lineStrings.forEach(l => {
            data.lineObj.features.push(...parseLineData(l))
        })
    }

    function showData() {
        drawMap(data.zips)
        drawBusses(data.busObj)
        drawLines(data.lineObj)
        return
    }

    function parseBusData(busStr) {
        // array for results
        let featureArray = []
        
        // split up bus text into an array
        let busArray = busStr.split('\n'); // get each bus with newline element
        let busArrayFilt = busArray.filter(b => b.length) // filter blank lines
        let busArraySplit = busArrayFilt.map(bus => bus.split(' ')) // split each bus into name and coords

        // convert the array of arrays into an array of geoJSON feature objects
        busArraySplit.forEach(element => {
            let busName = element[0]
            let busLong = +element[1]
            let busLat = +element[2]
            featureArray.push({
                "type": "Feature",
                "properties": {
                    "name": busName
                },
                "geometry": {
                    "type": "Point",
                    "coordinates": [busLong, busLat]
                }
            })
        });
        return featureArray;
    }

    function parseLineData(lineStr) {
        // array for the results
        let featureArray = []

        // parse the line string into an array
        let lineArray = lineStr.split('\n');
        let lineArrayFilt = lineArray.filter(l => l.length) // filter blank lines
        let lineArraySplit = lineArrayFilt.map(l => l.split(' '))


        console.log(lineArraySplit)
        // debugger;

        // convert the array of arrays into an array of geoJSON feature objects
        lineArraySplit.forEach(l => {
            featureArray.push({
                "type": "Feature",
                "properties": {
                    "name": l[1], 
                    "length": +l[3].slice(l[3].indexOf("Length=")+7), // extract chars after "="
                    "bus1": l[4].slice(l[4].indexOf("bus1=")+5, l[4].indexOf(".")), // extract chars after "=", before the "."
                    "bus2": l[5].slice(l[5].indexOf("bus2=")+5, l[5].indexOf(".")), // extract chars after "=", before the "."
                    "lineCode": l[9].slice(l[9].indexOf("Linecode=")+9), // extract chars after "="                    
                },
                "geometry": {
                    "type": "linestring",
                    "coordinates": [
                        // get x1, y1 coordinates by matching bus1 name to a bus in busObj and pulling the coordinates
                        data.busObj.features.find(f =>
                            f.properties.name === l[4].slice(l[4].indexOf("bus1=")+5, l[4].indexOf("."))
                        ).geometry.coordinates,
                        // get x2, y2 coordinates by matching bus2 name to a bus in busObj and pulling the coordinates
                        data.busObj.features.find(f =>
                            f.properties.name === l[5].slice(l[5].indexOf("bus2=")+5, l[5].indexOf("."))
                        ).geometry.coordinates
                    ]
                }
            })
        })
        return featureArray
    }

    function getMapConfig(){
        let width = 600;
        let height = 600;
        let container = d3.select("#map")
            .attr("height", height)
            .attr("width", width)
        return {width, height, container}
    }

    function getMapProjection(config) {
        let {width, height} = config;
        let projection = d3.geoMercator()
        let s0 = 10240
        let x0 = 21879
        let y0 = 7351
        let m = 70
        let b = 22
        let s = m * s0
        let x = m * (x0 - b)
        let y = m * (y0 - b)

        projection.scale(s).translate([x, y])
                    
        data.mapProjection = projection;
        return projection;
    }

    function drawBaseMap(container, zips, projection) {
        let path = d3.geoPath().projection(projection);

        container.selectAll("path")
            .data(zips)
            .enter()
            .append("path")
            .attr("d", d => path(d)) 
            .attr("stroke", "#ccc")
            .attr("fill", "#eee")
    }

    function addZoom() {
        let zoom = d3.zoom().on('zoom', handleZoom);
        function handleZoom(e) {
            d3.select('#map')
                .attr('transform', e.transform);
        }
        d3.select('#map').call(zoom)
    }

    function drawMap(geoJson) {
        let config = getMapConfig();
        let projection = getMapProjection(config);
        drawBaseMap(config.container, geoJson.features, projection)
        addZoom()
    }

    function drawBusses(busses) {
        let config = getMapConfig();
        let projection = getMapProjection(config);
        let container = config.container;
        let circles = container.selectAll("circle")
            .data(busses.features)
            .enter()
            .append("circle")
            .attr("r", 0.8)
            .attr("cx", d => projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[0])
            .attr("cy", d => projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[1])
            .attr("fill", "#2a5599")
    }

    function drawLines(powerLines) {
        let projection = data.mapProjection
        let container = d3.select("#map")
        let lines = container.selectAll("line")
            .data(powerLines.features)
            .enter()    
            .append("line")
            .attr("x1", d => projection([d.geometry.coordinates[0][0], d.geometry.coordinates[0][1]])[0])
            .attr("y1", d => projection([d.geometry.coordinates[0][0], d.geometry.coordinates[0][1]])[1])
            .attr("x2", d => projection([d.geometry.coordinates[1][0], d.geometry.coordinates[1][1]])[0])
            .attr("y2", d => projection([d.geometry.coordinates[1][0], d.geometry.coordinates[1][1]])[1])
            .attr("stroke", "#992a2a")
            .attr("stroke-width", 0.5)
            .style("opacity", 1)
    }

    loadData().then(parseData).then(showData).then(console.log("All Data: ", data))
    
</script>

</html>